package protocol.mysql;

import io.netty.buffer.Unpooled;
import io.netty.channel.ChannelHandlerContext;
import io.netty.channel.ChannelInboundHandlerAdapter;
import mqtt.AnalysisYaml;
import mqtt.KubeedgeClient;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import pojo.Message;

import java.net.SocketAddress;
import java.util.Date;
import java.util.Map;
import java.util.concurrent.ConcurrentHashMap;

/**
 * Mysql协议Handler
 *
 * @author 78445
 */
public class MysqlServerHandler extends ChannelInboundHandlerAdapter {
    private static final Logger logger = LoggerFactory.getLogger(MysqlServerHandler.class);
    private static final Map<SocketAddress, Boolean> statusMap = new ConcurrentHashMap<>();
    private static final byte[] GREETING_DATA = {
            0x5b, 0x00, 0x00, 0x00, 0x0a, 0x35, 0x2e, 0x37, 0x2e, 0x33, 0x33, 0x2d, 0x30, 0x75, 0x62, 0x75,
            0x6e, 0x74, 0x75, 0x30, 0x2e, 0x31, 0x36, 0x2e, 0x30, 0x34, 0x2e, 0x31, 0x00, 0x06, 0x00, 0x00,
            0x00, 0x72, 0x0b, 0x25, 0x0c, 0x17, 0x79, 0x77, 0x42, 0x00, (byte) 0xff, (byte) 0xf7, 0x08, 0x02, 0x00, (byte) 0xff,
            (byte) 0x81, 0x15, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x53, 0x58, 0x58, 0x3e,
            0x4a, 0x49, 0x74, 0x10, 0x1a, 0x34, 0x38, 0x29, 0x00, 0x6d, 0x79, 0x73, 0x71, 0x6c, 0x5f, 0x6e,
            0x61, 0x74, 0x69, 0x76, 0x65, 0x5f, 0x70, 0x61, 0x73, 0x73, 0x77, 0x6f, 0x72, 0x64, 0x00
    };

    private static final byte[] RESPONSE_OK_DATA = {0x07, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00};

    private static final byte[] RESPONSE_QUERY = {
            0x01, 0x00, 0x00, 0x01, 0x01, 0x27, 0x00, 0x00, 0x02, 0x03, 0x64, 0x65, 0x66, 0x00, 0x00,
            0x00, 0x11, 0x40, 0x40, 0x76, 0x65, 0x72, 0x73, 0x69, 0x6f, 0x6e, 0x5f, 0x63, 0x6f, 0x6d, 0x6d,
            0x65, 0x6e, 0x74, 0x00, 0x0c, 0x1c, 0x00, 0x10, 0x00, 0x00, 0x00, (byte) 0xfd, 0x00, 0x00, 0x1f, 0x00,
            0x00, 0x09, 0x00, 0x00, 0x03, 0x08, 0x28, 0x55, 0x62, 0x75, 0x6e, 0x74, 0x75, 0x29, 0x07, 0x00,
            0x00, 0x04, (byte) 0xfe, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00
    };

    private static final byte[] ERROR_DATA = {
            0x2d, 0x00, 0x00, 0x01, (byte) 0xff, 0x28, 0x04, 0x23, 0x34, 0x32, 0x30, 0x30, 0x30, 0x59, 0x6f,
            0x75, 0x20, 0x68, 0x61, 0x76, 0x65, 0x20, 0x61, 0x6e, 0x20, 0x65, 0x72, 0x72, 0x6f, 0x72,
            0x20, 0x69, 0x6e, 0x20, 0x79, 0x6f, 0x75, 0x72, 0x20, 0x53, 0x51, 0x4c, 0x20, 0x73, 0x79,
            0x6e, 0x74, 0x61, 0x78
    };

    @Override
    public void channelActive(ChannelHandlerContext ctx) throws Exception {
        SocketAddress address = ctx.channel().remoteAddress();
        ctx.writeAndFlush(Unpooled.copiedBuffer(RESPONSE_OK_DATA));
        statusMap.put(address, true);
        logger.info("mysql: " + address + " connected");
        Message msg = new Message();
        msg.setAddress(address.toString());
        msg.setMethod("Mysql");
        msg.setDate(new Date());
        KubeedgeClient.getClientInstance().putData(AnalysisYaml.toJsonObject(msg).toString());
        logger.info(msg.toString());
    }

    @Override
    public void channelInactive(ChannelHandlerContext ctx) throws Exception {
        SocketAddress address = ctx.channel().remoteAddress();
        statusMap.remove(address);
    }

    @Override
    public void handlerAdded(ChannelHandlerContext ctx) throws Exception {
        ctx.writeAndFlush(Unpooled.copiedBuffer(GREETING_DATA));
    }

    @Override
    public void channelRead(ChannelHandlerContext ctx, Object msg) throws Exception {
        SocketAddress address = ctx.channel().remoteAddress();
        logger.info("mysql: " + address + " msg: " + msg);
        boolean status = statusMap.get(address);
        if (status) {
            ctx.writeAndFlush(Unpooled.copiedBuffer(RESPONSE_QUERY));
            statusMap.put(address, false);
        } else {
            ctx.writeAndFlush(Unpooled.copiedBuffer(ERROR_DATA));
        }
    }

    @Override
    public void exceptionCaught(ChannelHandlerContext ctx, Throwable cause) throws Exception {
        cause.printStackTrace();
        ctx.close();
    }
}
